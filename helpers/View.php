<?PHP

namespace helpers;

/**
 * Helper class for rendering template
 *
 * @package    helpers
 * @copyright  Copyright (c) Tobias Zeising (http://www.aditu.de)
 * @license    GPLv3 (http://www.gnu.org/licenses/gpl-3.0.html)
 * @author     Tobias Zeising <tobias.zeising@aditu.de>
 * @author     arbk (https://aruo.net/)
 */
class View
{

    /**
     * encoding
     */
    const ENCODING = 'UTF-8';

    /**
     * current base url
     * @var string
     */
    public $base = '';

    /**
     * set global view vars
     */
    public function __construct()
    {
        $this->genMinifiedJsAndCss();
        $this->base = $this->getBaseUrl();
    }


    /**
     * Returns the base url of the page. If a base url was configured in the
     * config.ini this will be used. Otherwise base url will be generated by
     * globale server variables ($_SERVER).
     */
    public function getBaseUrl()
    {
        $base = '';

        // base url in config.ini file
        if (strlen(trim(\F3::get('base_url')))>0) {
            $base = \F3::get('base_url');
            $length = strlen($base);
            if ($length>0 && substr($base, $length-1, 1)!="/") {
                $base .= '/';
            }

        // auto generate base url
        } else {
            $lastSlash = strrpos($_SERVER['SCRIPT_NAME'], '/');
            $subdir = $lastSlash!==false ? substr($_SERVER['SCRIPT_NAME'], 0, $lastSlash) : '';

            $protocol = 'http';
            if (isset($_SERVER["HTTPS"]) && ($_SERVER["HTTPS"]=="on" || $_SERVER["HTTPS"]==1) ||
               (isset($_SERVER['HTTP_X_FORWARDED_PROTO'])) && $_SERVER['HTTP_X_FORWARDED_PROTO']=="https" ||
               (isset($_SERVER['HTTP_HTTPS'])) && $_SERVER['HTTP_HTTPS']=="https") {
                $protocol = 'https';
            }

            $port = '';
            if (($protocol == 'http' && $_SERVER["SERVER_PORT"]!="80") ||
                ($protocol == 'https' && $_SERVER["SERVER_PORT"]!="443")) {
                $port = ':' . $_SERVER["SERVER_PORT"];
            }
            //Override the port if nginx is the front end and the traffic is being forwarded
            if (isset($_SERVER["HTTP_X_FORWARDED_PORT"])) {
                $port = ':' . $_SERVER["HTTP_X_FORWARDED_PORT"];
            }

            $base = $protocol . '://' . $_SERVER["SERVER_NAME"] . $port . $subdir . '/';
        }

        return $base;
    }


    /**
     * render template
     *
     * @return string rendered html
     * @param string $template file
     */
    public function render($template)
    {
        ob_start();
        include $template;
        $content = ob_get_contents();
        ob_end_clean();
        return $content;
    }


    /**
     * send error message
     *
     * @return void
     * @param string $message
     */
    public function error($message)
    {
        header("HTTP/1.0 400 Bad Request");
        die($message);
    }


    /**
     * json_encode
     */
    protected function jsonEncode($data)
    {
        \F3::get('logger')->log('json_encode data: '.print_r($data, true), \TRACE);
        return json_encode($data);
    }

    /**
     * send error message as json string
     *
     * @return void
     * @param mixed $datan
     */
    public function jsonError($data)
    {
        header('Content-type: application/json');
        $this->error($this->jsonEncode($data));
    }


    /**
     * send success message as json string
     *
     * @return void
     * @param mixed $datan
     */
    public function jsonSuccess($data)
    {
        header('Content-type: application/json');
        die($this->jsonEncode($data));
    }



    /**
     * returns global JavaScript file name (all.js)
     *
     * @return string all.js file name
     */
    public static function getGlobalJsFileName()
    {
        return 'all-v' . \F3::get('version') . '.js';
    }


    /**
     * returns global CSS file name (all.css)
     *
     * @return string all.css file name
     */
    public static function getGlobalCssFileName()
    {
        return 'all-v' . \F3::get('version') . '.css';
    }



    /**
     * generate minified css and js
     *
     * @return void
     */
    public function genMinifiedJsAndCss()
    {
        // minify js
        $targetJs = \F3::get('BASEDIR').'/public/'.self::getGlobalJsFileName();
        if (!file_exists($targetJs) || \F3::get('DEBUG')!=0) {
            $js = "";
            foreach (\F3::get('js') as $file) {
                $js = $js . "\n" . $this->minifyJs(file_get_contents(\F3::get('BASEDIR').'/'.$file));
            }
            file_put_contents($targetJs, $js);
        }

        // minify css
        $targetCss = \F3::get('BASEDIR').'/public/'.self::getGlobalCssFileName();
        if (!file_exists($targetCss) || \F3::get('DEBUG')!=0) {
            $css = "";
            foreach (\F3::get('css') as $file) {
                $css = $css . "\n" . $this->minifyCss(file_get_contents(\F3::get('BASEDIR').'/'.$file));
            }
            file_put_contents($targetCss, $css);
        }
    }


    /**
     * minifies javascript if DEBUG mode is disabled
     *
     * @return minified javascript
     * @param javascript to minify
     */
    private function minifyJs($content)
    {
        if (\F3::get('DEBUG')!=0) {
            return $content;
        }
        return \JShrink\Minifier::minify($content);
    }


    /**
     * minifies css if DEBUG mode is disabled
     *
     * @return minified css
     * @param css to minify
     */
    private function minifyCss($content)
    {
        if (\F3::get('DEBUG')!=0) {
            return $content;
        }
        return \CssMin::minify($content);
    }



    /**
     * convert kana string.
     */
    public static function ckana($str, $option = 'KV')
    {
        return mb_convert_kana($str, $option, self::ENCODING);
    }

    /**
     * convert kana string with option 'KVs'.
     */
    public static function ckana_s($str)
    {
        return self::ckana($str, 'KVs');
    }

    /**
     * convert kana string with option 'KVa'.
     */
    public static function ckana_a($str)
    {
        return self::ckana($str, 'KVa');
    }

    /**
     * convert kana string with option 'KVas'.
     */
    public static function ckana_as($str)
    {
        return self::ckana($str, 'KVas');
    }



    /**
     * echo text.
     */
    private static function e($str, $output = true)
    {
        if ($output) {
            echo $str;
        }
        return $str;
    }

    /**
     * echo text for html string.
     */
    public static function eh($str, $output = true)
    {
        return self::e(
            htmlspecialchars($str, ENT_QUOTES|ENT_HTML5, self::ENCODING),
            $output
        );
    }

    /**
     * echo text with html string removed.
     */
    public static function et($str, $output = true)
    {
        return self::e(
            self::eh(strip_tags(html_entity_decode($str, ENT_QUOTES|ENT_HTML5, self::ENCODING)), false),
            $output
        );
    }

    /**
     * echo lead sentence text with html string removed.
     */
    public static function el($str, $output = true, $width = null, $trimmarker = '...')
    {
        $lsstr = trim(str_replace(
            array('ã€€', '   ', '  ', "\r\n", "\r", "\n"),
            array( ' ',   ' ',  ' ',     '',   '',   ''),
            self::et($str, false)
        ));

        if (is_numeric($width)) {
            $lsstr = mb_strimwidth(
                $lsstr,
                0,
                $width,
                $trimmarker,
                self::ENCODING
            );
        }

        return self::e($lsstr, $output);
    }
}
